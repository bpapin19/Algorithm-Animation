{"ast":null,"code":"/* MERGESORT */export function getMergeSortAnimations(array){var animations=[];if(array.length<=1)return array;var auxiliaryArray=array.slice();mergeSortHelper(array,0,array.length-1,auxiliaryArray,animations);return animations;}function mergeSortHelper(mainArray,startIdx,endIdx,auxiliaryArray,animations){if(startIdx===endIdx)return;var middleIdx=Math.floor((startIdx+endIdx)/2);mergeSortHelper(auxiliaryArray,startIdx,middleIdx,mainArray,animations);mergeSortHelper(auxiliaryArray,middleIdx+1,endIdx,mainArray,animations);doMerge(mainArray,startIdx,middleIdx,endIdx,auxiliaryArray,animations);}function doMerge(mainArray,startIdx,middleIdx,endIdx,auxiliaryArray,animations){var k=startIdx;var i=startIdx;var j=middleIdx+1;while(i<=middleIdx&&j<=endIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([i,j]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([i,j]);if(auxiliaryArray[i]<=auxiliaryArray[j]){// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\nanimations.push([k,auxiliaryArray[i]]);mainArray[k++]=auxiliaryArray[i++];}else{// We overwrite the value at index k in the original array with the\n// value at index j in the auxiliary array.\nanimations.push([k,auxiliaryArray[j]]);mainArray[k++]=auxiliaryArray[j++];}}while(i<=middleIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([i,i]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([i,i]);// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\nanimations.push([k,auxiliaryArray[i]]);mainArray[k++]=auxiliaryArray[i++];}while(j<=endIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([j,j]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([j,j]);// We overwrite the value at index k in the original array with the\n// value at index j in the auxiliary array.\nanimations.push([k,auxiliaryArray[j]]);mainArray[k++]=auxiliaryArray[j++];}}/* QUICKSORT */export function getQuickSortAnimations(array){var animations=[];if(array.length<=1)return array;doQuick(array,0,array.length-1,animations);return animations;}function doQuick(array,low,high,animations){if(high<=low)return;//partition array\nvar j=partition(array,low,high,animations);// sort low\ndoQuick(array,low,j-1,animations);//sort high\ndoQuick(array,j+1,high,animations);}function partition(array,low,high,animations){var i=low,j=high+1;var pElement=array[low];// Set color of partitioning element to black\nanimations.push([\"partition1\",low]);while(true){while(array[++i]<pElement){if(i===high)break;}while(pElement<array[--j]){if(j===low)break;}if(i>=j)break;exch(array,i,j,animations);}exch(array,low,j,animations);animations.push([\"partition2\",low]);return j;}function exch(array,i,j,animations){var temp=array[i];// Set elements being compared to Red\nanimations.push([\"comparison1\",i,j]);// Swap sizes of both indexes\nanimations.push([\"swap\",i,array[j]]);animations.push([\"swap\",j,temp]);var swap=array[i];array[i]=array[j];array[j]=swap;// Change elements being compared back to green\nanimations.push([\"comparison2\",i,j]);}/* SELCTION SORT */export function getSelectionSortAnimations(array){var animations=[];var N=array.length;for(var i=0;i<N;i++){var min=i;for(var j=i+1;j<N;j++){if(array[j]<array[min])min=j;}exch(array,i,min,animations);}return animations;}/* INSERTION SORT */export function getInsertionSortAnimations(array){var animations=[];var N=array.length;for(var i=1;i<N;i++){for(var j=i;j>0&&array[j]<array[j-1];j--){exch(array,j,j-1,animations);}}return animations;}","map":{"version":3,"sources":["/Users/brandonpapin/Desktop/CPSC 349 FE Web/sort-animation/src/SortingAlgorithms/SortingAlgorithms.js"],"names":["getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","doMerge","k","i","j","push","getQuickSortAnimations","doQuick","low","high","partition","pElement","exch","temp","swap","getSelectionSortAnimations","N","min","getInsertionSortAnimations"],"mappings":"AAAA,eACA,MAAO,SAASA,CAAAA,sBAAT,CAAgCC,KAAhC,CAAuC,CAC5C,GAAMC,CAAAA,UAAU,CAAG,EAAnB,CACA,GAAID,KAAK,CAACE,MAAN,EAAgB,CAApB,CAAuB,MAAOF,CAAAA,KAAP,CACvB,GAAMG,CAAAA,cAAc,CAAGH,KAAK,CAACI,KAAN,EAAvB,CACAC,eAAe,CAACL,KAAD,CAAQ,CAAR,CAAWA,KAAK,CAACE,MAAN,CAAe,CAA1B,CAA6BC,cAA7B,CAA6CF,UAA7C,CAAf,CACA,MAAOA,CAAAA,UAAP,CACD,CAED,QAASI,CAAAA,eAAT,CACEC,SADF,CAEEC,QAFF,CAGEC,MAHF,CAIEL,cAJF,CAKEF,UALF,CAME,CACA,GAAIM,QAAQ,GAAKC,MAAjB,CAAyB,OACzB,GAAMC,CAAAA,SAAS,CAAGC,IAAI,CAACC,KAAL,CAAW,CAACJ,QAAQ,CAAGC,MAAZ,EAAsB,CAAjC,CAAlB,CACAH,eAAe,CAACF,cAAD,CAAiBI,QAAjB,CAA2BE,SAA3B,CAAsCH,SAAtC,CAAiDL,UAAjD,CAAf,CACAI,eAAe,CAACF,cAAD,CAAiBM,SAAS,CAAG,CAA7B,CAAgCD,MAAhC,CAAwCF,SAAxC,CAAmDL,UAAnD,CAAf,CACAW,OAAO,CAACN,SAAD,CAAYC,QAAZ,CAAsBE,SAAtB,CAAiCD,MAAjC,CAAyCL,cAAzC,CAAyDF,UAAzD,CAAP,CACD,CAED,QAASW,CAAAA,OAAT,CACEN,SADF,CAEEC,QAFF,CAGEE,SAHF,CAIED,MAJF,CAKEL,cALF,CAMEF,UANF,CAOE,CACA,GAAIY,CAAAA,CAAC,CAAGN,QAAR,CACA,GAAIO,CAAAA,CAAC,CAAGP,QAAR,CACA,GAAIQ,CAAAA,CAAC,CAAGN,SAAS,CAAG,CAApB,CACA,MAAOK,CAAC,EAAIL,SAAL,EAAkBM,CAAC,EAAIP,MAA9B,CAAsC,CACpC;AACA;AACAP,UAAU,CAACe,IAAX,CAAgB,CAACF,CAAD,CAAIC,CAAJ,CAAhB,EACA;AACA;AACAd,UAAU,CAACe,IAAX,CAAgB,CAACF,CAAD,CAAIC,CAAJ,CAAhB,EACA,GAAIZ,cAAc,CAACW,CAAD,CAAd,EAAqBX,cAAc,CAACY,CAAD,CAAvC,CAA4C,CAC1C;AACA;AACAd,UAAU,CAACe,IAAX,CAAgB,CAACH,CAAD,CAAIV,cAAc,CAACW,CAAD,CAAlB,CAAhB,EACAR,SAAS,CAACO,CAAC,EAAF,CAAT,CAAiBV,cAAc,CAACW,CAAC,EAAF,CAA/B,CACD,CALD,IAKO,CACL;AACA;AACAb,UAAU,CAACe,IAAX,CAAgB,CAACH,CAAD,CAAIV,cAAc,CAACY,CAAD,CAAlB,CAAhB,EACAT,SAAS,CAACO,CAAC,EAAF,CAAT,CAAiBV,cAAc,CAACY,CAAC,EAAF,CAA/B,CACD,CACF,CACD,MAAOD,CAAC,EAAIL,SAAZ,CAAuB,CACrB;AACA;AACAR,UAAU,CAACe,IAAX,CAAgB,CAACF,CAAD,CAAIA,CAAJ,CAAhB,EACA;AACA;AACAb,UAAU,CAACe,IAAX,CAAgB,CAACF,CAAD,CAAIA,CAAJ,CAAhB,EACA;AACA;AACAb,UAAU,CAACe,IAAX,CAAgB,CAACH,CAAD,CAAIV,cAAc,CAACW,CAAD,CAAlB,CAAhB,EACAR,SAAS,CAACO,CAAC,EAAF,CAAT,CAAiBV,cAAc,CAACW,CAAC,EAAF,CAA/B,CACD,CACD,MAAOC,CAAC,EAAIP,MAAZ,CAAoB,CAClB;AACA;AACAP,UAAU,CAACe,IAAX,CAAgB,CAACD,CAAD,CAAIA,CAAJ,CAAhB,EACA;AACA;AACAd,UAAU,CAACe,IAAX,CAAgB,CAACD,CAAD,CAAIA,CAAJ,CAAhB,EACA;AACA;AACAd,UAAU,CAACe,IAAX,CAAgB,CAACH,CAAD,CAAIV,cAAc,CAACY,CAAD,CAAlB,CAAhB,EACAT,SAAS,CAACO,CAAC,EAAF,CAAT,CAAiBV,cAAc,CAACY,CAAC,EAAF,CAA/B,CACD,CACF,CAED,eACA,MAAO,SAASE,CAAAA,sBAAT,CAAgCjB,KAAhC,CAAuC,CAC5C,GAAMC,CAAAA,UAAU,CAAG,EAAnB,CACA,GAAID,KAAK,CAACE,MAAN,EAAgB,CAApB,CAAuB,MAAOF,CAAAA,KAAP,CACvBkB,OAAO,CAAClB,KAAD,CAAQ,CAAR,CAAWA,KAAK,CAACE,MAAN,CAAe,CAA1B,CAA6BD,UAA7B,CAAP,CACA,MAAOA,CAAAA,UAAP,CACD,CAED,QAASiB,CAAAA,OAAT,CAAiBlB,KAAjB,CAAwBmB,GAAxB,CAA6BC,IAA7B,CAAmCnB,UAAnC,CAA+C,CAC7C,GAAImB,IAAI,EAAID,GAAZ,CAAiB,OACjB;AACA,GAAIJ,CAAAA,CAAC,CAAGM,SAAS,CAACrB,KAAD,CAAQmB,GAAR,CAAaC,IAAb,CAAmBnB,UAAnB,CAAjB,CACA;AACAiB,OAAO,CAAClB,KAAD,CAAQmB,GAAR,CAAaJ,CAAC,CAAC,CAAf,CAAkBd,UAAlB,CAAP,CACA;AACAiB,OAAO,CAAClB,KAAD,CAAQe,CAAC,CAAC,CAAV,CAAaK,IAAb,CAAmBnB,UAAnB,CAAP,CACD,CAED,QAASoB,CAAAA,SAAT,CAAmBrB,KAAnB,CAA0BmB,GAA1B,CAA+BC,IAA/B,CAAqCnB,UAArC,CAAiD,CAC/C,GAAIa,CAAAA,CAAC,CAAGK,GAAR,CAAaJ,CAAC,CAAGK,IAAI,CAAC,CAAtB,CACA,GAAIE,CAAAA,QAAQ,CAAGtB,KAAK,CAACmB,GAAD,CAApB,CACA;AACAlB,UAAU,CAACe,IAAX,CAAgB,CAAC,YAAD,CAAeG,GAAf,CAAhB,EACA,MAAO,IAAP,CAAa,CACX,MAAOnB,KAAK,CAAC,EAAEc,CAAH,CAAL,CAAaQ,QAApB,CAA8B,CAC5B,GAAIR,CAAC,GAAKM,IAAV,CAAgB,MACjB,CACD,MAAOE,QAAQ,CAAGtB,KAAK,CAAC,EAAEe,CAAH,CAAvB,CAA8B,CAC5B,GAAIA,CAAC,GAAKI,GAAV,CAAe,MAChB,CACD,GAAIL,CAAC,EAAIC,CAAT,CAAY,MACZQ,IAAI,CAACvB,KAAD,CAAQc,CAAR,CAAWC,CAAX,CAAcd,UAAd,CAAJ,CACD,CACDsB,IAAI,CAACvB,KAAD,CAAQmB,GAAR,CAAaJ,CAAb,CAAgBd,UAAhB,CAAJ,CACAA,UAAU,CAACe,IAAX,CAAgB,CAAC,YAAD,CAAeG,GAAf,CAAhB,EACA,MAAOJ,CAAAA,CAAP,CACD,CAED,QAASQ,CAAAA,IAAT,CAAcvB,KAAd,CAAqBc,CAArB,CAAwBC,CAAxB,CAA2Bd,UAA3B,CAAuC,CACrC,GAAIuB,CAAAA,IAAI,CAAGxB,KAAK,CAACc,CAAD,CAAhB,CACA;AACAb,UAAU,CAACe,IAAX,CAAgB,CAAC,aAAD,CAAgBF,CAAhB,CAAmBC,CAAnB,CAAhB,EACA;AACAd,UAAU,CAACe,IAAX,CAAgB,CAAC,MAAD,CAASF,CAAT,CAAYd,KAAK,CAACe,CAAD,CAAjB,CAAhB,EACAd,UAAU,CAACe,IAAX,CAAgB,CAAC,MAAD,CAASD,CAAT,CAAYS,IAAZ,CAAhB,EACA,GAAIC,CAAAA,IAAI,CAAGzB,KAAK,CAACc,CAAD,CAAhB,CACAd,KAAK,CAACc,CAAD,CAAL,CAAWd,KAAK,CAACe,CAAD,CAAhB,CACAf,KAAK,CAACe,CAAD,CAAL,CAAWU,IAAX,CACA;AACAxB,UAAU,CAACe,IAAX,CAAgB,CAAC,aAAD,CAAgBF,CAAhB,CAAmBC,CAAnB,CAAhB,EACD,CAED,mBACA,MAAO,SAASW,CAAAA,0BAAT,CAAoC1B,KAApC,CAA2C,CAChD,GAAMC,CAAAA,UAAU,CAAG,EAAnB,CACA,GAAI0B,CAAAA,CAAC,CAAG3B,KAAK,CAACE,MAAd,CACA,IAAK,GAAIY,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGa,CAApB,CAAuBb,CAAC,EAAxB,CAA4B,CAC1B,GAAIc,CAAAA,GAAG,CAAGd,CAAV,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAGD,CAAC,CAAC,CAAf,CAAkBC,CAAC,CAAGY,CAAtB,CAAyBZ,CAAC,EAA1B,CAA8B,CAC5B,GAAIf,KAAK,CAACe,CAAD,CAAL,CAAWf,KAAK,CAAC4B,GAAD,CAApB,CAA2BA,GAAG,CAAGb,CAAN,CAC5B,CACDQ,IAAI,CAACvB,KAAD,CAAQc,CAAR,CAAWc,GAAX,CAAgB3B,UAAhB,CAAJ,CACD,CACD,MAAOA,CAAAA,UAAP,CACD,CAED,oBACA,MAAO,SAAS4B,CAAAA,0BAAT,CAAoC7B,KAApC,CAA2C,CAChD,GAAMC,CAAAA,UAAU,CAAG,EAAnB,CACA,GAAI0B,CAAAA,CAAC,CAAG3B,KAAK,CAACE,MAAd,CACA,IAAK,GAAIY,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGa,CAApB,CAAuBb,CAAC,EAAxB,CAA4B,CAC1B,IAAK,GAAIC,CAAAA,CAAC,CAAGD,CAAb,CAAgBC,CAAC,CAAG,CAAJ,EAAUf,KAAK,CAACe,CAAD,CAAL,CAAWf,KAAK,CAACe,CAAC,CAAC,CAAH,CAA1C,CAAkDA,CAAC,EAAnD,CAAuD,CACrDQ,IAAI,CAACvB,KAAD,CAAQe,CAAR,CAAWA,CAAC,CAAC,CAAb,CAAgBd,UAAhB,CAAJ,CACD,CACF,CACD,MAAOA,CAAAA,UAAP,CACD","sourcesContent":["/* MERGESORT */\nexport function getMergeSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n  return animations;\n}\n  \nfunction mergeSortHelper(\n  mainArray,\n  startIdx,\n  endIdx,\n  auxiliaryArray,\n  animations,\n) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction doMerge(\n  mainArray,\n  startIdx,\n  middleIdx,\n  endIdx,\n  auxiliaryArray,\n  animations,\n) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, j]);\n    // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    animations.push([i, j]);\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n      // We overwrite the value at index k in the original array with the\n      // value at index i in the auxiliary array.\n      animations.push([k, auxiliaryArray[i]]);\n      mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      // We overwrite the value at index k in the original array with the\n      // value at index j in the auxiliary array.\n      animations.push([k, auxiliaryArray[j]]);\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, i]);\n    // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    animations.push([i, i]);\n    // We overwrite the value at index k in the original array with the\n    // value at index i in the auxiliary array.\n    animations.push([k, auxiliaryArray[i]]);\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n  while (j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([j, j]);\n    // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n    animations.push([j, j]);\n    // We overwrite the value at index k in the original array with the\n    // value at index j in the auxiliary array.\n    animations.push([k, auxiliaryArray[j]]);\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n}\n\n/* QUICKSORT */\nexport function getQuickSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doQuick(array, 0, array.length - 1, animations);\n  return animations;\n}\n\nfunction doQuick(array, low, high, animations) {\n  if (high <= low) return;\n  //partition array\n  let j = partition(array, low, high, animations);\n  // sort low\n  doQuick(array, low, j-1, animations);\n  //sort high\n  doQuick(array, j+1, high, animations);\n}\n\nfunction partition(array, low, high, animations) {\n  let i = low, j = high+1;\n  let pElement = array[low];\n  // Set color of partitioning element to black\n  animations.push([\"partition1\", low]);\n  while (true) {\n    while (array[++i] < pElement) {\n      if (i === high) break;\n    }\n    while (pElement < array[--j]) {\n      if (j === low) break;\n    }\n    if (i >= j) break;\n    exch(array, i, j, animations);\n  }\n  exch(array, low, j, animations);\n  animations.push([\"partition2\", low]);\n  return j;\n}\n\nfunction exch(array, i, j, animations) {\n  let temp = array[i];\n  // Set elements being compared to Red\n  animations.push([\"comparison1\", i, j]);\n  // Swap sizes of both indexes\n  animations.push([\"swap\", i, array[j]]);\n  animations.push([\"swap\", j, temp]);\n  let swap = array[i];\n  array[i] = array[j];\n  array[j] = swap;\n  // Change elements being compared back to green\n  animations.push([\"comparison2\", i, j]);\n}\n\n/* SELCTION SORT */\nexport function getSelectionSortAnimations(array) {\n  const animations = [];\n  let N = array.length;\n  for (let i = 0; i < N; i++) {\n    let min = i;\n    for (let j = i+1; j < N; j++) {\n      if (array[j] < array[min]) min = j;\n    }\n    exch(array, i, min, animations);\n  }\n  return animations;\n}\n\n/* INSERTION SORT */\nexport function getInsertionSortAnimations(array) {\n  const animations = [];\n  let N = array.length;\n  for (let i = 1; i < N; i++) {\n    for (let j = i; j > 0 && (array[j] < array[j-1]); j--) {\n      exch(array, j, j-1, animations);\n    }\n  }\n  return animations;\n}\n\n\n"]},"metadata":{},"sourceType":"module"}